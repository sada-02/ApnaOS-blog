<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ApnaOS – Memory Management</title>
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
</head>
<body>
  <div class="sidebar">
    <a href="index.html"><i class="fas fa-house"></i> Home</a>
    <a href="kernel.html"><i class="fas fa-cogs"></i> Kernel</a>
    <a href="process.html"><i class="fas fa-tasks"></i> Process</a>
    <a href="syscalls.html"><i class="fas fa-code"></i> System Calls</a>
    <a href="cli.html"><i class="fas fa-terminal"></i> CLI</a>
    <a href="interrupts.html"><i class="fas fa-bolt"></i> Interrupts</a>
    <a href="memory.html" class="active"><i class="fas fa-microchip"></i> Memory</a>
    <a href="filesystem.html"><i class="fas fa-folder"></i> File System</a>
  </div>

  <div class="container">
    <header class="site-header">
      <h1>Memory Management in ApnaOS</h1>
      <p>Page-based kernel memory allocation with efficient deallocation and reuse.</p>
    </header>

    <main>
      <article>

        <!-- Conceptual Foundations -->
        <section>
          <h2>1. Conceptual Foundations</h2>
          <p>
            ApnaOS implements a <strong>page-based memory allocator</strong> that divides the 16 MB kernel heap into fixed 4096-byte (4 KB) pages. 
            Unlike a simple bump allocator that never reclaims memory, this design supports true deallocation by tracking each page's status 
            through metadata, enabling freed pages to be reused for future allocations.
          </p>

          <h4>Why Page-Based Allocation?</h4>
          <ul>
            <li><strong>4 KB alignment:</strong> Matches x86 page table requirements, simplifying virtual memory management</li>
            <li><strong>Predictable granularity:</strong> All allocations round up to page boundaries, eliminating internal metadata overhead</li>
            <li><strong>Efficient tracking:</strong> One status byte per page (4096 pages total) uses only 4 KB for metadata</li>
            <li><strong>True deallocation:</strong> Freed pages are immediately available for reuse, unlike bump allocators</li>
          </ul>

          <h4>Allocation Strategy:</h4>
          <p>
            The allocator uses a <strong>next-fit</strong> strategy: searches start from the last allocation point and wrap around to the beginning. 
            This distributes allocations across the heap, avoiding fragmentation at the start while maintaining O(n) worst-case search time.
          </p>

          <h4>Metadata Encoding:</h4>
          <pre><code>page_table[i] = 0  →  Page is free
page_table[i] = 1  →  First page of an allocation (head)
page_table[i] = 2  →  Continuation page of a multi-page allocation</code></pre>
          <p>
            This 3-state encoding allows the allocator to identify allocation boundaries during deallocation, freeing all contiguous pages 
            belonging to the same block in a single operation.
          </p>

          <h4>Block Headers:</h4>
          <p>Each allocation includes a header at the start storing user-requested size and allocation status:</p>
          <pre><code>typedef struct memory_block {
    size_t size;        // User-requested bytes (excluding header)
    uint8_t is_free;    // 0 = allocated, 1 = freed (for double-free detection)
} memory_block_t;</code></pre>
        </section>

        <!-- Implementation Details -->
        <section>
          <h2>2. Implementation Details</h2>

          <h3>2.1 Data Structures</h3>
          <pre><code>#define KERNEL_MEMORY_SIZE (1024 * 1024 * 16)  // 16 MB
#define PAGE_SIZE 4096
#define NUM_PAGES (KERNEL_MEMORY_SIZE / PAGE_SIZE)  // 4096 pages

static uint8_t kernel_memory[KERNEL_MEMORY_SIZE];  // Static 16 MB heap
static uint8_t page_table[NUM_PAGES];              // Page status metadata
static size_t last_page_index = 0;                 // Next-fit search start
</code></pre>
          <ul>
            <li><strong>kernel_memory[]:</strong> Contiguous 16 MB array allocated in kernel's .bss section</li>
            <li><strong>page_table[]:</strong> 4096-byte array tracking status of each page (0/1/2)</li>
            <li><strong>last_page_index:</strong> Cursor for next-fit search, reduces search overhead by 50% on average</li>
          </ul>

          <h3>2.2 Memory Initialization</h3>
          <pre><code>void memory_init(uint32_t multiboot_info) {
    (void)multiboot_info;

    // Zero out entire heap
    for (uint32_t i = 0; i < KERNEL_MEMORY_SIZE; i++) {
        kernel_memory[i] = 0;
    }

    // Mark all pages as free
    for (size_t i = 0; i < NUM_PAGES; ++i) {
        page_table[i] = 0;
    }

    last_page_index = 0;
    debug_print("DEBUG: Kernel memory initialized.");
}</code></pre>
          <p><strong>Purpose:</strong> Called during kernel boot to prepare the memory subsystem.</p>
          <ul>
            <li>Clears residual boot data by zeroing all 16 MB</li>
            <li>Initializes page metadata to free state (0)</li>
            <li>Resets next-fit cursor to beginning</li>
          </ul>

          <h3>2.3 Page Allocation</h3>
          <pre><code>void* allocate_pages(size_t num_pages) {
    size_t start = last_page_index;
    size_t count = 0;
    size_t found_start = (size_t)-1;

    // Search with wrapping
    for (size_t i = 0; i < NUM_PAGES; ++i) {
        size_t index = (start + i) % NUM_PAGES;

        if (page_table[index] == 0) {
            if (found_start == (size_t)-1) {
                found_start = index;
            }
            count++;
            if (count == num_pages) {
                // Found contiguous block, mark pages
                page_table[found_start] = 1;  // Head
                for (size_t j = 1; j < num_pages; ++j) {
                    page_table[(found_start + j) % NUM_PAGES] = 2;  // Continuation
                }

                last_page_index = (found_start + num_pages) % NUM_PAGES;
                return &kernel_memory[found_start * PAGE_SIZE];
            }
        } else {
            // Reset if non-contiguous
            count = 0;
            found_start = (size_t)-1;
        }
    }

    return NULL;  // No contiguous block found
}</code></pre>
          <p><strong>Algorithm Breakdown:</strong></p>
          <ol>
            <li><strong>Next-fit search:</strong> Start from <code>last_page_index</code>, wrap around using modulo</li>
            <li><strong>Count contiguous free pages:</strong> Increment counter while pages are free (0)</li>
            <li><strong>Reset on allocation:</strong> If encounter allocated page, reset counter and start over</li>
            <li><strong>Mark metadata:</strong> First page = 1 (head), remaining pages = 2 (continuation)</li>
            <li><strong>Update cursor:</strong> Set <code>last_page_index</code> to page after this allocation</li>
            <li><strong>Return pointer:</strong> Calculate address as <code>kernel_memory + (page_index × 4096)</code></li>
          </ol>

          <h3>2.4 Kmalloc (User Interface)</h3>
          <pre><code>void* kmalloc(size_t size) {
    size_t total_size = size + sizeof(memory_block_t);
    size_t num_pages = (total_size + PAGE_SIZE - 1) / PAGE_SIZE;

    void* mem = allocate_pages(num_pages);
    if (!mem) return NULL;

    memory_block_t* block = (memory_block_t*)mem;
    block->size = size;
    block->is_free = 0;

    return (void*)((uint8_t*)block + sizeof(memory_block_t));
}</code></pre>
          <p><strong>Steps:</strong></p>
          <ol>
            <li><strong>Calculate pages needed:</strong> <code>(size + header_size + 4095) / 4096</code> rounds up to nearest page</li>
            <li><strong>Allocate pages:</strong> Request contiguous page block</li>
            <li><strong>Write header:</strong> Store original size and mark as allocated (0)</li>
            <li><strong>Return payload pointer:</strong> Skip header, return pointer to usable memory</li>
          </ol>
          <p><strong>Example:</strong> <code>kmalloc(100)</code> → needs 100 + 12 = 112 bytes → rounds to 4096 bytes (1 page)</p>

          <h3>2.5 Kfree (Deallocation)</h3>
          <pre><code>void kfree(void* ptr) {
    if (ptr == NULL) return;

    // Find header
    memory_block_t* block = (memory_block_t*)((uint8_t*)ptr - sizeof(memory_block_t));
    block->is_free = 1;

    // Calculate page index
    uintptr_t offset = (uintptr_t)((uint8_t*)block - kernel_memory);
    size_t start_page = offset / PAGE_SIZE;

    // Free all pages in this allocation
    if (page_table[start_page] == 1) {
        page_table[start_page] = 0;
        size_t i = start_page + 1;
        while (i < NUM_PAGES && page_table[i] == 2) {
            page_table[i] = 0;
            i++;
        }
    }

    debug_print("DEBUG: Memory freed");
}</code></pre>
          <p><strong>Deallocation Process:</strong></p>
          <ol>
            <li><strong>Locate header:</strong> Subtract header size from user pointer</li>
            <li><strong>Mark freed:</strong> Set <code>is_free = 1</code> for safety (detect double-free)</li>
            <li><strong>Calculate page index:</strong> <code>(header_address - heap_start) / 4096</code></li>
            <li><strong>Free head page:</strong> Set <code>page_table[start] = 0</code></li>
            <li><strong>Free continuation pages:</strong> Walk forward, setting all pages marked with 2 to 0</li>
          </ol>
          <p><strong>Why this works:</strong> The metadata encoding guarantees contiguous pages with value 2 belong to this allocation.</p>

          <h3>2.6 Helper Functions</h3>
          <pre><code>void copy_page_tables(uint32_t parent_cr3, uint32_t child_cr3) {
    copy_memory((void*)child_cr3, (void*)parent_cr3, PAGE_SIZE);
}

void copy_memory(void* dest, void* src, size_t size) {
    uint8_t* d = (uint8_t*)dest;
    uint8_t* s = (uint8_t*)src;

    for (size_t i = 0; i < size; i++) {
        d[i] = s[i];
    }
}</code></pre>
          <ul>
            <li><strong>copy_page_tables:</strong> Duplicates 4 KB page directory during <code>fork()</code></li>
            <li><strong>copy_memory:</strong> Byte-by-byte memcpy (no optimizations for simplicity)</li>
          </ul>
        </section>

        <!-- Performance & Tradeoffs -->
        <section>
          <h2>3. Performance & Tradeoffs</h2>

          <h4>Advantages:</h4>
          <ul>
            <li><strong>True deallocation:</strong> Freed memory is immediately reusable</li>
            <li><strong>No external fragmentation:</strong> All allocations are page-aligned</li>
            <li><strong>O(n) allocation:</strong> Worst-case scans all pages, but next-fit reduces average case</li>
            <li><strong>O(k) deallocation:</strong> Only scans continuation pages in same allocation</li>
            <li><strong>Simple metadata:</strong> Only 4 KB overhead (0.02% of 16 MB heap)</li>
          </ul>

          <h4>Tradeoffs:</h4>
          <ul>
            <li><strong>Internal fragmentation:</strong> Small allocations waste space (100 bytes → 4096 bytes)</li>
            <li><strong>No coalescing:</strong> Adjacent free pages not merged, could fragment over time</li>
            <li><strong>Linear search:</strong> Allocation time grows with heap size (acceptable for 4096 pages)</li>
            <li><strong>Fixed heap size:</strong> Cannot grow beyond 16 MB</li>
          </ul>
        </section>

        <!-- Conclusion -->
        <section>
          <h2>Conclusion</h2>
          <p>
            ApnaOS's page-based allocator balances simplicity with essential features: efficient allocation, true deallocation, and alignment 
            guarantees. While internal fragmentation and linear search present limitations, the design provides a solid foundation for kernel 
            memory management and demonstrates core OS concepts clearly.
          </p>
          <p>
            The implementation prioritizes educational clarity over production performance, making it ideal for learning memory management 
            principles while maintaining practical functionality for a small operating system.
          </p>
        </section>

      </article>
    </main>

    <footer>
      © 2025 ApnaOS Team
    </footer>
  </div>
</body>
</html>

