<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ApnaOS ‚Äì Kernel</title>
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
</head>
<body>
  <div class="sidebar">
    <a href="index.html"><i class="fas fa-house"></i> Home</a>
    <a href="kernel.html" class="active"><i class="fas fa-cogs"></i> Kernel</a>
    <a href="process.html"><i class="fas fa-tasks"></i> Process</a>
    <a href="syscalls.html"><i class="fas fa-code"></i> System Calls</a>
    <a href="cli.html"><i class="fas fa-terminal"></i> CLI</a>
    <a href="interrupts.html"><i class="fas fa-bolt"></i> Interrupts</a>
    <a href="memory.html"><i class="fas fa-microchip"></i> Memory</a>
    <a href="filesystem.html"><i class="fas fa-folder"></i> File System</a>
  </div>

  <div class="container">
    <header class="site-header">
      <h1>Kernel Architecture in ApnaOS</h1>
      <p>A comprehensive, step-by-step guide through our kernel‚Äôs bootstrap, initialization, and core services.</p>
    </header>
    
    <main>
      <article>

        <!-- Introduction -->
        <section>
          <h2>1. Introduction</h2>
          <p>
            The kernel is the core of ApnaOS, responsible for managing hardware resources, providing abstractions (memory, processes, files), and serving as the runtime for all processes. In this post, we‚Äôll explore how the kernel boots, sets up vital CPU and memory structures, initializes subsystems, and launches the interactive CLI or scheduled processes.
          </p>
        </section>

        <!-- Multiboot Header -->
        <section>
          <h2>Multiboot Header</h2>
          <pre><code>__attribute__((section(".multiboot")))
            __attribute__((used)) static const struct {
                uint32_t magic;
                uint32_t flags;
                uint32_t checksum;
            } multiboot_header = {
                0x1BADB002,
                0x00010003,
                -(0x1BADB002 + 0x00010003)
            };
            </code></pre>
            <ul>
              <li>Placed in the ‚Äú.multiboot‚Äù section so the bootloader can find it before the kernel is relocated.</li>
              <li><code>magic</code> must be <code>0x1BADB002</code> to identify a Multiboot‚Äëcompliant kernel.</li>
              <li><code>flags</code> (<code>0x00010003</code>) requests memory and video information from the bootloader.</li>
              <li><code>checksum</code> is computed so that <code>magic + flags + checksum</code> equals zero, validating the header‚Äôs integrity.</li>
            </ul>
        </section>

        <!-- Implementation -->
        <section>
          <h2>Implementation Details</h2>

          <h3>1. Conversions and debugging statements</h3>
          <h4>atoi</h4>
          <pre><code>int atoi(const char *s) {
            int num = 0;
            int sign = 1;
            if (*s == '-') {
                sign = -1;
                s++;
            }
            while (*s) {
                if (*s >= '0' && *s <= '9') {
                    num = num * 10 + (*s - '0');
                } else {
                    break;
                }
                s++;
            }
            return sign * num;
        }
        </code></pre>
            <ul>
            <li>Detects an optional leading <code>-</code> and records the sign.</li>
            <li>Iterates over digit characters, converting each from ASCII to its numeric value and accumulating into <code>num</code>.</li>
            <li>Stops parsing when a non‚Äëdigit is encountered.</li>
            <li>Returns the integer multiplied by the sign.</li>
            </ul>
          </ul>
          <h4>itoa</h4>
          <pre><code>void itoa(int n, char *str) {
            int i = 0, sign = n;
            if(sign < 0) n = -n;
            do {
                str[i++] = n % 10 + '0';
                n /= 10;
            } while(n > 0);
            if(sign < 0) str[i++] = '-';
            str[i] = '\0';
            int j = 0;
            char temp;
            for(j = 0; j < i / 2; j++){
                temp = str[j];
                str[j] = str[i - j - 1];
                str[i - j - 1] = temp;
            }
        }        
        </code></pre>
            <ul>
                <li>Records the original sign and makes <code>n</code> non‚Äënegative for digit extraction.</li>
                <li>Extracts digits in reverse order by repeatedly taking <code>n % 10</code> and dividing by 10.</li>
                <li>Appends a minus sign if the original number was negative.</li>
                <li>Adds a null terminator and then reverses the string in place to correct the digit order.</li>
            </ul>
          </ul>
          <h4>int_to_hex</h4>
          <pre><code>void int_to_hex(uint32_t num, char *buffer) {
            const char hex_chars[] = "0123456789ABCDEF";
            buffer[0] = '0'; buffer[1] = 'x';
            for (int i = 0; i < 8; i++)
                buffer[i + 2] = hex_chars[(num >> ((7 - i) * 4)) & 0xF];
            buffer[10] = '\0';
        }          
        </code></pre>
            <ul>
                <li>Prefixes the string with "0x".</li>
                <li>Extracts each nibble (4 bits) from most significant to least by shifting and masking.</li>
                <li>Maps the nibble value to its hexadecimal character.</li>
                <li>Produces an 8‚Äëdigit hex representation plus the "0x" prefix and null terminator.</li>
            </ul>
          </ul>
          <h4>int_to_dec</h4>
          <pre><code>void int_to_dec(uint32_t num, char *buffer) {
            char temp[16];
            int pos = 0;
            if(num == 0){ buffer[0] = '0'; buffer[1] = '\0'; return; }
            while(num > 0 && pos < 15){
                temp[pos++] = '0' + (num % 10);
                num /= 10;
            }
            int i;
            for(i = 0; i < pos; i++)
                buffer[i] = temp[pos - i - 1];
            buffer[i] = '\0';
        }            
        </code></pre>
            <ul>
              <li>Handles zero as a special case immediately.</li>
              <li>Extracts decimal digits into a temporary buffer in reverse order.</li>
              <li>Copies them back into buffer in the correct forward order.</li>
              <li>Ensures null termination.</li>
            </ul>
          </ul>
          <h4>int_to_str</h4>
          <pre><code>void int_to_str(int value, char *buffer) {
            int i = 0;
            if(value == 0){ buffer[i++] = '0'; buffer[i] = '\0'; return; }
            char temp[10];
            int j = 0;
            while(value){
                temp[j++] = '0' + (value % 10);
                value /= 10;
            }
            while(j > 0){
                buffer[i++] = temp[--j];
            }
            buffer[i] = '\0';
        }               
        </code></pre>
            <ul>
              <li>Similar to <code>int_to_dec</code> but for signed integers.</li>
              <li>Extracts digits into <code>temp</code>, then moves them into <code>buffer</code> in reverse order of extraction.</li>
              <li>Handles zero explicitly.</li>
              <li>Null‚Äëterminates the result.</li>

            </ul>
          </ul>

          <h4>debug_print</h4>
          <pre><code> void debug_print(const char *msg) {
            serial_print(msg);
            serial_print("\r\n");
        }
        
        </code></pre>
            <ul>
              <li>Sends the supplied string to the serial port.</li>
              <li>Appends a carriage return and newline for readability in the serial console.</li>
            </ul>
          </ul>

          <h4>debug_int</h4>
          <pre><code> void debug_int(uint32_t val) {
            char buffer[16];
            int_to_hex(val, buffer);
            debug_print(buffer);
        }
        </code></pre>
            <ul>
              <li>Converts the 32‚Äëbit integer to an 8‚Äëdigit hexadecimal string.</li>
              <li>Prints that string (with line break) via the serial console.</li>
            </ul>
          </ul>

        <h3>2. Screen Management & Timer Functions</h3>
        
        <h4>Timer Initialization & Control</h4>
          <pre><code>static volatile uint32_t timer_ticks = 0;

void timer_callback(void) {
    timer_ticks++;
}

void init_pit(uint32_t frequency) {
    uint32_t divisor = 1193180 / frequency;
    outb(0x43, 0x36);              // Command byte
    outb(0x40, divisor & 0xFF);     // Low byte
    outb(0x40, (divisor >> 8) & 0xFF); // High byte
}

void sleep_ms(uint32_t milliseconds) {
    uint32_t ticks_to_wait = (milliseconds * 100) / 1000;
    uint32_t start_ticks = timer_ticks;
    while ((timer_ticks - start_ticks) < ticks_to_wait) {
        asm volatile("hlt");
    }
}</code></pre>
            <ul>
                <li><strong>timer_ticks:</strong> Global counter incremented by timer interrupt (100 Hz)</li>
                <li><strong>init_pit():</strong> Programs the Programmable Interval Timer to fire at specified frequency (base clock 1.193182 MHz)</li>
                <li><strong>sleep_ms():</strong> Busy-waits for specified milliseconds using timer ticks, halting CPU between checks</li>
                <li>Used for shutdown countdown and precise timing operations</li>
            </ul>

        <h4>Scrollback Buffer Management</h4>
          <pre><code>typedef struct {
    char text[80];
    uint8_t attrs[80];
} BufferLine;

BufferLine scrollback[1000];
BufferLine saved_screen[25];

void save_top_line_to_scrollback(void) {
    volatile char *video = VGA_MEMORY;
    int pos = scroll_write_pos % SCROLLBACK_SIZE;
    
    for (int col = 0; col < VGA_WIDTH; col++) {
        int offset = col * 2;
        scrollback[pos].text[col] = video[offset];
        scrollback[pos].attrs[col] = video[offset + 1];
    }
    scroll_write_pos++;
    if (scroll_lines_used < SCROLLBACK_SIZE) {
        scroll_lines_used++;
    }
}</code></pre>
            <ul>
                <li><strong>BufferLine:</strong> Stores one line of text (80 chars) plus attribute bytes</li>
                <li><strong>scrollback[]:</strong> Circular buffer holding 1000 lines of scrollback history</li>
                <li><strong>saved_screen[]:</strong> Preserves current 25-line display when entering scroll mode</li>
                <li><strong>save_top_line_to_scrollback():</strong> Called before scrolling, saves top line to history before it's lost</li>
                <li>Enables Page Up/Down navigation through output history</li>
            </ul>
        
        <h4>scroll_screen</h4>
          <pre><code>void scroll_screen(void) {
    if (in_scroll_mode) return;  // Don't scroll while viewing history
    
    save_top_line_to_scrollback();  // Save top line before it's lost
    
    volatile char *video = VGA_MEMORY;
    for (int row = 1; row < VGA_HEIGHT; row++){
        for (int col = 0; col < VGA_WIDTH; col++){
            int from = (row * VGA_WIDTH + col) * 2;
            int to = ((row - 1) * VGA_WIDTH + col) * 2;
            video[to] = video[from];
            video[to+1] = video[from+1];
        }
    }
    int last_row = (VGA_HEIGHT - 1) * VGA_WIDTH * 2;
    for (int col = 0; col < VGA_WIDTH; col++){
        video[last_row + col*2] = ' ';
        video[last_row + col*2 + 1] = 0x07;
    }
    vga_row = VGA_HEIGHT - 1;
    vga_col = 0;
}</code></pre>
            <ul>
                <li><strong>Prevents scrolling during scroll mode:</strong> Returns early if user is viewing history</li>
                <li><strong>Preserves history:</strong> Saves top line to scrollback buffer before overwriting</li>
                <li>Copies each character cell (two bytes: ASCII and attribute) from the second row onward up one row</li>
                <li>Calculates source and destination indices in the VGA buffer for each position</li>
                <li>Clears the bottom row by writing spaces with attribute 0x07 (gray on black)</li>
                <li>Resets the cursor to the first column of the last row</li>
            </ul>
        <h4>putchar</h4>
          <pre><code>void putchar(char c) {
    if (in_scroll_mode) {
        exit_scroll_mode();  // Exit scroll mode on any output
    }
    
    volatile char *video = VGA_MEMORY;
    if(c == '\n'){
        vga_row++;
        vga_col = 0;
    } else if(c == '\b'){  // Backspace support
        if(vga_col > 0){
            vga_col--;
            int offset = (vga_row * VGA_WIDTH + vga_col) * 2;
            video[offset] = ' ';  // Clear character
            video[offset+1] = 0x07;
        }
    } else {
        int offset = (vga_row * VGA_WIDTH + vga_col) * 2;
        video[offset] = c;
        video[offset+1] = 0x07;
        vga_col++;
        if(vga_col >= VGA_WIDTH){ vga_row++; vga_col = 0; }
    }
    if(vga_row >= VGA_HEIGHT) scroll_screen();
}</code></pre>
            <ul>
              <li><strong>Scroll mode handling:</strong> Exits scroll mode if user viewing history to show new output</li>
              <li><strong>Newline handling:</strong> Advances the row and resets the column to beginning</li>
              <li><strong>Backspace support:</strong> Moves cursor back and clears the character visually</li>
              <li><strong>Character rendering:</strong> Computes the byte offset in VGA memory and writes character + attribute (0x07 = gray on black)</li>
              <li><strong>Word wrap:</strong> Increments the column, wrapping to the next row when reaching screen width (80 chars)</li>
              <li><strong>Auto-scroll:</strong> Invokes scrolling when the cursor moves past the bottom of the screen (row 25)</li>
            </ul>
        <h4>print_to_screen</h4>
          <pre><code>void print_to_screen(const char *message)
            {
                while(*message){ putchar(*message); message++; }
            }                 
          </code></pre>
            <ul>
              <li>Iterates through a null‚Äëterminated string and calls putchar for each character to render the entire message on screen.</li>
            </ul>
        <h4>Process Command Table</h4>
          <pre><code>typedef struct {
    const char *name;
    void (*func)(void);
} ProcessCommand;

ProcessCommand process_commands[] = {
    {"dummy1", dummy_process_1},
    {"dummy2", dummy_process_2},
    {"dummy3", dummy_process_3}
};
const int num_process_commands = sizeof(process_commands)/sizeof(ProcessCommand);

// Also available: simplesys, multisys (syscall test processes)
extern void simplesys(void);
extern void multisys(void);</code></pre>
            <ul>
              <li><strong>ProcessCommand struct:</strong> Pairs command names with function pointers for dynamic dispatch</li>
              <li><strong>process_commands[]:</strong> Array of available test processes that can be queued via CLI</li>
              <li><strong>dummy1/2/3:</strong> Simple test processes demonstrating basic scheduling</li>
              <li><strong>simplesys:</strong> Fork test with one parent creating one child (tests fork/wait/exit)</li>
              <li><strong>multisys:</strong> Advanced test with one parent creating three children sequentially</li>
              <li><strong>num_process_commands:</strong> Computed at compile time for loop bounds checking</li>
              <li>New processes can be added by extending this array and implementing the function</li>
            </ul>
        <h4>read_line</h4>
          <pre><code>extern volatile int input_ready;
            extern volatile char input_line[BUFFER_SIZE];
            void read_line(char *buffer, int max_length)
            {
                while(!input_ready){ asm volatile("hlt"); }
                int i = 0;
                while(input_line[i] != '\0' && i < max_length-1){ buffer[i] = input_line[i]; i++; }
                buffer[i] = '\0';
                input_ready = 0;
            }            
          </code></pre>
            <ul>
              <ul>
                <li>Relies on two volatile externs‚Äî<code>input_ready</code> and <code>input_line[]</code>‚Äîto communicate with an interrupt or ISR that fills the input buffer.</li>
                <li>Spins in a low‚Äëpower wait (<code>hlt</code>) until <code>input_ready</code> becomes nonzero.</li>
                <li>Copies characters from <code>input_line</code> into the provided buffer, stopping when it reaches either the terminating <code>'\0'</code> or the maximum allowed length minus one.</li>
                <li>Appends a <code>'\0'</code> to properly terminate the string and resets <code>input_ready</code> to zero so the next input can be signaled.</li>
              </ul>
            </ul>

            <h3>3. CLI loop</h3>
          <pre><code>void cli_loop(void) {
            char input[MAX_INPUT_LENGTH];
        
            while (1) {
                print_to_screen("CLI> ");
                read_line(input, MAX_INPUT_LENGTH);
                char *token1 = strtok(input, " \t");
                if (!token1) {
                    continue;
                }
                if (strcmp(token1, "exit") == 0) {
                    print_to_screen("Exiting kernel CLI...\n");
                    break;
                }
                else if (strcmp(token1, "process") == 0) {
                    char *token2 = strtok(NULL, " \t");
                    if (!token2) {
                        print_to_screen("Usage: process <dummy1|dummy2|dummy3|syscall test|process test|start> [priority]\n");
                        continue;
                    }
                    if (strcmp(token2, "start") == 0) {
                        print_to_screen("Starting scheduled processes...\n");
                        schedule();
                        continue;
                    }
                    
                    int priority = 1;
                    char *token3 = strtok(NULL, " \t"); 
                    char *token4 = strtok(NULL, " \t");
        
                    if (strcmp(token2, "syscall") == 0 && token3 && strcmp(token3, "test") == 0) {
                        if (token4) priority = atoi(token4);
                        print_to_screen("Queueing syscall_test process...\n");
                        
                        create_process(
                            get_new_pid(),
                            (uint32_t *) syscall_test,
                            priority, 1, 2
                        );
                        continue;
                    }
        
                    if (strcmp(token2, "process") == 0 && token3 && strcmp(token3, "test") == 0) {
                        if (token4) priority = atoi(token4);
                        print_to_screen("Queueing process_test process...\n");
                
                        create_process(
                            get_new_pid(),
                            (uint32_t *) process_test,
                            priority, 1, 2
                        );
                        continue;
                    }
        
                    if (token3) {
                        priority = atoi(token3);
                    }
                    
                    int found = 0;
                    for (int i = 0; i < num_process_commands; i++) {
                        if (strcmp(token2, process_commands[i].name) == 0) {
                            print_to_screen("Queueing process...\n");
                            
                            create_process(
                                get_new_pid(),
                                (uint32_t *) process_commands[i].func,
                                priority,
                                1, 2
                            );
                            found = 1;
                            break;
                        }
                    }
                    if (!found) {
                        print_to_screen("Error: Unknown process name.\n");
                    }
                }
                else if (strcmp(token1, "file") == 0) {
                    char *operation = strtok(NULL, " \t");
                    if (!operation) {
                    print_to_screen("Usage: file <operation> <filename> [args]\n");
                    continue;
                    }
        
                    if (strcmp(operation, "make") == 0) {
                    char *filename = strtok(NULL, " \t");
                    if (!filename) {
                        print_to_screen("Usage: file make <filename>\n");
                        continue;
                    }
                    if (create_file(filename) == -1) {
                        print_to_screen("Error: Failed to create file.\n");
                    } else {
                        print_to_screen("File created successfully.\n");
                    }
                    }
                    else if (strcmp(operation, "read") == 0) {
                    char *filename = strtok(NULL, " \t");
                    if (!filename) {
                        print_to_screen("Usage: file read <filename>\n");
                        continue;
                    }
                    char buffer[128];
                    int bytes_read = read_file(filename, buffer, sizeof(buffer));
                    if (bytes_read == -1) {
                        print_to_screen("Error: Failed to read file.\n");
                    } else {
                        buffer[bytes_read] = '\0'; // Null-terminate the string
                        print_to_screen("File content: ");
                        print_to_screen(buffer);
                        print_to_screen("\n");
                    }
                    }
                    else if (strcmp(operation, "write") == 0) {
                    char *filename = strtok(NULL, " \t");
                    char *data = strtok(NULL, "\n"); // Remaining input as data
                    if (!filename || !data) {
                        print_to_screen("Usage: file write <filename> <data>\n");
                        continue;
                    }
                    if (write_file(filename, data, strlen(data)) == -1) {
                        print_to_screen("Error: Failed to write to file.\n");
                    } else {
                        print_to_screen("Data written to file successfully.\n");
                    }
                    }
                    else if (strcmp(operation, "append") == 0) {
                    char *filename = strtok(NULL, " \t");
                    char *data = strtok(NULL, "\n"); // Remaining input as data
                    if (!filename || !data) {
                        print_to_screen("Usage: file append <filename> <data>\n");
                        continue;
                    }
                    if (append_to_file(filename, data, strlen(data)) == -1) {
                        print_to_screen("Error: Failed to append to file.\n");
                    } else {
                        print_to_screen("Data appended to file successfully.\n");
                    }
                    }
                    else if (strcmp(operation, "rm") == 0) {
                    char *filename = strtok(NULL, " \t");
                    if (!filename) {
                        print_to_screen("Usage: file rm <filename>\n");
                        continue;
                    }
                    if (delete_file(filename) == -1) {
                        print_to_screen("Error: Failed to delete file.\n");
                    } else {
                        print_to_screen("File deleted successfully.\n");
                    }
                    }
                    else if (strcmp(operation, "ls") == 0) {
                    list_files();
                    }
                    else {
                    print_to_screen("Unknown file operation. Use 'make', 'read', 'write', 'append', 'rm', or 'ls'.\n");
                    }
                }
                else if (strcmp(token1, "ls") == 0) {
                    list_files();
                }
                else {
                    print_to_screen("Unknown command. Use 'process', 'file', 'ls', or 'exit'.\n");
                }
            }
        }
          </code></pre>
            <ul>
              <ul>
                <li>Enters an infinite loop presenting a simple command‚Äëline interface.</li>
                <li>Displays the prompt "CLI> " and waits for user input via <code>read_line</code>.</li>
                <li>Tokenization:
                  <ul>
                    <li>Splits the input line on spaces or tabs into <code>token1</code>, the primary command.</li>
                    <li>If <code>token1</code> is empty, restarts the loop.</li>
                  </ul>
                </li>
                <li><code>exit</code> Command:
                  <ul>
                    <li>If <code>token1</code> is "exit", breaks out of the loop, ending the CLI.</li>
                  </ul>
                </li>
                <li><code>process</code> Command:
                  <ul>
                    <li>Reads <code>token2</code> to decide the subcommand or process name.</li>
                    <li>If missing, shows usage for process commands.</li>
                    <li>If <code>token2</code> is "start":
                      <ul>
                        <li>Prints a message and calls the scheduler to begin running queued processes.</li>
                      </ul>
                    </li>
                    <li>Handles special tests:
                      <ul>
                        <li>"syscall test" and "process test" each accept an optional priority (<code>token4</code>) and enqueue a corresponding test process with default or specified priority.</li>
                      </ul>
                    </li>
                    <li>Otherwise treats <code>token2</code> as the name of one of the dummy processes:
                      <ul>
                        <li>Converts an optional <code>token3</code> into a numeric priority.</li>
                        <li>Searches the <code>process_commands[]</code> array for a matching name.</li>
                        <li>On match, enqueues that process with the chosen priority.</li>
                        <li>If no match, reports ‚ÄúUnknown process name.‚Äù</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li><code>file</code> Command:
                  <ul>
                    <li>Reads operation (e.g., make, read, write, append, rm, ls).</li>
                    <li>For each operation:
                      <ul>
                        <li><code>make</code>: expects a filename, creates a file, reports success or failure.</li>
                        <li><code>read</code>: reads up to 128‚ÄØbytes into a buffer, null‚Äëterminates it, and prints its contents.</li>
                        <li><code>write</code>/<code>append</code>: reads a filename and the rest of the input as data, writes or appends it to the file, and reports the result.</li>
                        <li><code>rm</code>: deletes the named file.</li>
                        <li><code>ls</code>: lists all files.</li>
                      </ul>
                    </li>
                    <li>If an unrecognized operation is given, prints an error with valid options.</li>
                  </ul>
                </li>
                <li><code>ls</code> Command (Standalone):
                  <ul>
                    <li>When <code>token1</code> is "ls" by itself, simply calls <code>list_files()</code>.</li>
                  </ul>
                </li>
                <li>Fallback:
                  <ul>
                    <li>Any other <code>token1</code> triggers a generic ‚ÄúUnknown command‚Äù message, reminding the user of the valid top‚Äëlevel commands: <code>process</code>, <code>file</code>, <code>ls</code>, or <code>exit</code>.</li>
                  </ul>
                </li>
              </ul>
            </ul>

          <h3>4. Kernel Main - Initialization Sequence</h3>
          <pre><code>void kernel_main(uint32_t multiboot_info) {
    serial_init();
    debug_print("DEBUG: Entering kernel_main.");
    
    // Display 30 debug lines for testing scrollback buffer
    for (int i = 1; i <= 30; i++){
        print_to_screen("Debug: line ");
        char num[10];
        int_to_str(i, num);
        print_to_screen(num);
        print_to_screen("\n");
    }
    
    memory_init(multiboot_info);
    debug_print("DEBUG: Memory initialized.");

    create_file_system();
    debug_print("DEBUG: Filesystem initialized.");
    
    init_user_system();  // Initialize multi-user support
    debug_print("DEBUG: User system initialized.");
    
    gdt_install();
    print_to_screen("DEBUG: GDT installed.\n");
    pic_remap();
    idt_install();
    irq_install();
    print_to_screen("DEBUG: IDT and IRQ handlers installed.\n");
    init_keyboard();
    init_pit(100);  // Initialize timer at 100 Hz
    register_interrupt_handler(32, timer_callback);
    
    print_to_screen("DEBUG: Keyboard initialized. Press keys!\n");
    asm volatile("sti");  // Enable interrupts
    init_syscalls();
    debug_print("DEBUG: System calls initialized.");

    init_process_management();
    debug_print("DEBUG: Process management initialized.");
    cli_loop();  // Enter interactive shell
    
    asm volatile("cli");
    print_to_screen("Kernel execution terminated.\n");
    while(1){ asm volatile("hlt"); }
}</code></pre>

          <h4>Initialization Order & Rationale:</h4>
          <ol>
            <li><strong>Serial Communication:</strong> Enables debug output to serial console (critical for development/debugging)</li>
            <li><strong>Entry Message:</strong> Confirms kernel successfully reached C code from bootloader</li>
            <li><strong>Scrollback Test:</strong> Prints 30 lines to test VGA output and populate scrollback buffer for Page Up/Down testing</li>
            <li><strong>Memory Management:</strong> Parses Multiboot info, sets up page tables, initializes kernel heap
              <ul>
                <li>Must happen before any dynamic allocation</li>
                <li>Establishes virtual memory framework</li>
              </ul>
            </li>
            <li><strong>Filesystem:</strong> Formats simulated disk, initializes inode table, creates root directory
              <ul>
                <li>Sets up in-memory filesystem (1024 blocks √ó 4KB each)</li>
                <li>Creates hierarchical directory structure</li>
              </ul>
            </li>
            <li><strong>User System:</strong> Creates root user, initializes user authentication structures
              <ul>
                <li>Sets up multi-user support with password hashing</li>
                <li>Creates user_space_inodes array for isolated file spaces</li>
              </ul>
            </li>
            <li><strong>GDT (Global Descriptor Table):</strong> Sets up memory segments for kernel/user mode
              <ul>
                <li>Configures code and data segments</li>
                <li>Enables protected mode memory protection</li>
              </ul>
            </li>
            <li><strong>PIC Remapping:</strong> Moves hardware IRQs from 0x08-0x0F to 0x20-0x2F
              <ul>
                <li>Prevents conflict with CPU exceptions (0x00-0x1F)</li>
                <li>Critical for proper interrupt handling</li>
              </ul>
            </li>
            <li><strong>IDT (Interrupt Descriptor Table):</strong> Installs interrupt handlers for exceptions and IRQs
              <ul>
                <li>Sets up gates for all 256 interrupt vectors</li>
                <li>Configures privilege levels and handler addresses</li>
              </ul>
            </li>
            <li><strong>IRQ Handlers:</strong> Registers specific handlers for timer, keyboard, etc.</li>
            <li><strong>Keyboard Driver:</strong> Initializes PS/2 keyboard controller and scancode translation tables
              <ul>
                <li>Sets up command history arrays</li>
                <li>Configures shift/caps lock state tracking</li>
              </ul>
            </li>
            <li><strong>PIT (Programmable Interval Timer):</strong> Programs timer to fire at 100 Hz
              <ul>
                <li>Provides timing for sleep_ms() and shutdown countdown</li>
                <li>Divisor = 1193180 / 100 = 11932</li>
              </ul>
            </li>
            <li><strong>Timer Callback:</strong> Registers timer_callback to increment timer_ticks on IRQ0</li>
            <li><strong>Enable Interrupts:</strong> <code>sti</code> instruction allows hardware interrupts to fire
              <ul>
                <li>Must happen AFTER all interrupt handlers are installed</li>
                <li>Enables keyboard input and timer</li>
              </ul>
            </li>
            <li><strong>System Calls:</strong> Sets up syscall interface for fork/wait/yield/exit
              <ul>
                <li>Configures software interrupt mechanism</li>
                <li>Enables process management syscalls</li>
              </ul>
            </li>
            <li><strong>Process Management:</strong> Initializes ready queue, zombie list, scheduler
              <ul>
                <li>Sets up round-robin scheduling</li>
                <li>Prepares process table and PID allocation</li>
              </ul>
            </li>
            <li><strong>CLI Loop:</strong> Enters interactive command-line interface
              <ul>
                <li>Displays username@path> prompt</li>
                <li>Processes user commands until "exit"</li>
                <li>Handles file/directory/process/user operations</li>
              </ul>
            </li>
            <li><strong>Shutdown:</strong> Disables interrupts, prints termination message, halts CPU forever</li>
          </ol>

          <h4>Debug Output Sequence:</h4>
          <pre><code>DEBUG: Entering kernel_main.
Debug: line 1
...
Debug: line 30
DEBUG: Kernel memory initialized.
DEBUG: Memory initialized.
DEBUG: Disk formatted and file system reset.
DEBUG: File system created.
DEBUG: Filesystem initialized.
DEBUG: User system initialized with root user.
DEBUG: User system initialized.
DEBUG: GDT installed.
DEBUG: IDT and IRQ handlers installed.
DEBUG: Keyboard initialized. Press keys!
DEBUG: System calls initialized
DEBUG: System calls initialized.
DEBUG: Process queues initialized.
DEBUG: Process management system initialized.
DEBUG: Process management initialized.

root@/> _  [Interactive prompt appears]</code></pre>
            </section>
        <!-- Conclusion -->
        <section>
          <h2>Conclusion & Current Status</h2>
          <p>
            ApnaOS has evolved from a basic kernel into a fully functional operating system demonstrating core OS concepts. The kernel successfully handles:
          </p>
          
          <h4>‚úÖ Implemented Features:</h4>
          <ul>
            <li><strong>Multiboot bootloader:</strong> GRUB-based boot with protected mode transition</li>
            <li><strong>Memory management:</strong> Paging with page tables, kernel heap allocation</li>
            <li><strong>Interrupt handling:</strong> IDT, PIC remapping, ISRs for exceptions and IRQs</li>
            <li><strong>VGA text mode:</strong> 80√ó25 display with scrollback buffer (1000 lines)</li>
            <li><strong>Scrolling navigation:</strong> Page Up/Down for history, ESC to exit scroll mode</li>
            <li><strong>Timer support:</strong> PIT at 100Hz for sleep_ms() and shutdown countdown</li>
            <li><strong>Keyboard driver:</strong> Full scancode support including extended keys (arrows, Page Up/Down)</li>
            <li><strong>Command history:</strong> Per-user history (20 commands) with up/down arrow navigation</li>
            <li><strong>Filesystem:</strong> Inode-based with hierarchical directories, full path traversal (cd path/to/dir, cd .., cd ~)</li>
            <li><strong>Multi-user system:</strong> Password-protected user spaces with isolated file systems</li>
            <li><strong>User authentication:</strong> Password hashing and secure user switching</li>
            <li><strong>Access control:</strong> Owner-based file permissions (root can access all)</li>
            <li><strong>Process management:</strong> Round-robin scheduler with PCB and context switching</li>
            <li><strong>System calls:</strong> fork, wait, yield, exit for process control</li>
            <li><strong>Interactive CLI:</strong> Comprehensive shell with 30+ commands</li>
            <li><strong>Test programs:</strong> simplesys (single fork) and multisys (multiple forks) demonstrating syscalls</li>
          </ul>

          <h4>üéØ Future Enhancements:</h4>
          <ul>
            <li><strong>Copy-on-write:</strong> Optimize fork by sharing pages until write occurs</li>
            <li><strong>Persistent storage:</strong> Extend filesystem to real disk or virtual disk image</li>
            <li><strong>exec syscall:</strong> Load and execute new programs (replacing current process)</li>
            <li><strong>Pipes & redirection:</strong> Implement | and > operators for command chaining</li>
            <li><strong>User-mode processes:</strong> Run processes in ring 3 with proper privilege separation</li>
            <li><strong>IPC mechanisms:</strong> Message queues, shared memory, semaphores</li>
            <li><strong>Dynamic linking:</strong> Load shared libraries at runtime</li>
            <li><strong>Networking stack:</strong> TCP/IP implementation for network communication</li>
            <li><strong>Graphics mode:</strong> VESA/framebuffer support beyond VGA text mode</li>
          </ul>

          <p>
            The kernel demonstrates a complete OS foundation suitable for education and further development. Each component is well-documented, modular, and extensible, making it an excellent learning resource for operating system concepts.
          </p>
        </section>

      </article>
    </main>
    
    <footer>
      ¬© 2025 ApnaOS Team
    </footer>
  </div>
</body>
</html>
