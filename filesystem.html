<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ApnaOS – File System</title>
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
</head>
<body>
  <div class="sidebar">
    <a href="index.html"><i class="fas fa-house"></i> Home</a>
    <a href="kernel.html"><i class="fas fa-cogs"></i> Kernel</a>
    <a href="process.html"><i class="fas fa-tasks"></i> Process</a>
    <a href="syscalls.html"><i class="fas fa-code"></i> System Calls</a>
    <a href="cli.html"><i class="fas fa-terminal"></i> CLI</a>
    <a href="interrupts.html"><i class="fas fa-bolt"></i> Interrupts</a>
    <a href="memory.html"><i class="fas fa-microchip"></i> Memory</a>
    <a href="filesystem.html" class="active"><i class="fas fa-folder"></i> File System</a>
  </div>

  <div class="container">
    <header class="site-header">
      <h1>File System in ApnaOS</h1>
      <p>An in-depth look at our block-based VFS: design, APIs, and implementation.</p>
    </header>

    <main>
      <article>
        <section>
          <h2>1. Conceptual Foundations</h2>
          <p>
            ApnaOS employs a simple in-memory virtual file system (VFS) to simulate disk operations. The key concepts include:
          </p>
          <ul>
            <li><strong>Blocks:</strong> Fixed-size units (4 KB) used for data storage.</li>
            <li><strong>Superblock:</strong> Metadata about the filesystem—total blocks, free blocks, and block size.</li>
            <li><strong>Inodes:</strong> Structures that describe files, storing file size and direct block pointers.</li>
            <li><strong>Directory:</strong> A flat root directory mapping filenames to inode numbers.</li>
            <li><strong>Block Bitmap:</strong> A simple array indicating which blocks are free or allocated.</li>
          </ul>
        </section>

        <section>
          <h2>2. On-Disk (Simulated) Format</h2>
          <p>
            Our simulated disk is an array of <code>BLOCK_COUNT</code> blocks, each <code>BLOCK_SIZE</code> bytes. We limit each file to at most <code>MAX_BLOCKS_PER_FILE</code> blocks (8 KB).
          </p>
          <ul>
            <li><strong>Blocks:</strong> 1024 blocks → 4 MB total.</li>
            <li><strong>Block Size:</strong> 4096 bytes (4 KB).</li>
            <li><strong>Max File Size:</strong> 2 blocks = 8 KB.</li>
            <li><strong>Max Files:</strong> Defined by <code>MAX_FILES</code> in <code>filesystem.h</code>.</li>
          </ul>
        </section>

        <section>
          <h2>3. Core Data Structures</h2>
          <pre><code>typedef struct {
    uint32_t magic;
    uint32_t total_blocks;
    uint32_t free_blocks;
    uint32_t block_size;
} Superblock;

typedef struct {
    uint32_t inode_number;
    uint32_t size;               // file size in bytes
    int32_t  blocks[MAX_BLOCKS_PER_FILE];
    int32_t  indirect_block;
} Inode;

typedef struct {
    char     filename[MAX_FILENAME_LEN];
    uint32_t inode_number;
} DirectoryEntry;

// Simulated disk storage
char     storage[BLOCK_COUNT][BLOCK_SIZE];
int      block_bitmap[BLOCK_COUNT];
Inode    inode_table[MAX_FILES];
DirectoryEntry root_directory[MAX_FILES];
Superblock sb;
</code></pre>
        </section>

        <section>
          <h2>4. Filesystem Initialization</h2>
          <p>Formatting the disk resets superblock, inodes, directory, and block bitmap:</p>
          <pre><code>void format_disk() {
    sb.magic = 0x12345678;
    sb.total_blocks = BLOCK_COUNT;
    sb.free_blocks = BLOCK_COUNT;
    sb.block_size  = BLOCK_SIZE;

    // Clear inodes
    for (int i = 0; i < MAX_FILES; i++) {
        inode_table[i].inode_number = 0;
        inode_table[i].size = 0;
        memset(inode_table[i].blocks, -1, sizeof(inode_table[i].blocks));
        inode_table[i].indirect_block = -1;
    }

    // Clear directory
    for (int i = 0; i < MAX_FILES; i++) {
        root_directory[i].inode_number = 0;
    }

    // Clear block bitmap
    memset(block_bitmap, 0, sizeof(block_bitmap));

    debug_print("DEBUG: Disk formatted and file system reset.");
}

void create_file_system() {
    format_disk();
    debug_print("DEBUG: File system created.");
}
</code></pre>
        </section>

        <section>
          <h2>5. File Creation & Inode Allocation</h2>
          <p>Creating a file involves picking a free inode and block, then adding a directory entry:</p>
          <pre><code>int allocate_inode() {
    for (int i = 0; i < MAX_FILES; i++) {
        if (inode_table[i].inode_number == 0) {
            inode_table[i].inode_number = i + 1;
            return i;
        }
    }
    return -1;
}

int allocate_block() {
    for (int i = 0; i < BLOCK_COUNT; i++) {
        if (!block_bitmap[i]) {
            block_bitmap[i] = 1;
            sb.free_blocks--;
            return i;
        }
    }
    return -1;
}

int create_file(const char* filename) {
    int in = allocate_inode();
    if (in < 0) return -1;
    int blk = allocate_block();
    if (blk < 0) {
        inode_table[in].inode_number = 0;
        return -1;
    }
    inode_table[in].size = 0;
    inode_table[in].blocks[0] = blk;

    // Add to root directory
    for (int i = 0; i < MAX_FILES; i++) {
        if (!root_directory[i].inode_number) {
            strncpy(root_directory[i].filename, filename, MAX_FILENAME_LEN);
            root_directory[i].inode_number = in + 1;
            break;
        }
    }
    debug_print("DEBUG: File created.");
    return in;
}
</code></pre>
        </section>

        <section>
          <h2>6. Read, Write, and Append</h2>
          <p>Operations on file data use direct block pointers:</p>
          <pre><code>int write_file(const char* fname, const char* buf, size_t sz) {
    // Locate inode via directory
    int in = find_inode(fname);
    if (in < 0) return -1;
    int blk = inode_table[in].blocks[0];
    size_t w = (sz > BLOCK_SIZE) ? BLOCK_SIZE : sz;
    memcpy(storage[blk], buf, w);
    inode_table[in].size = w;
    return w;
}

int read_file(const char* fname, char* buf, size_t sz) {
    int in = find_inode(fname);
    if (in < 0) return -1;
    int blk = inode_table[in].blocks[0];
    size_t r = (sz > inode_table[in].size) ? inode_table[in].size : sz;
    memcpy(buf, storage[blk], r);
    return r;
}

int append_to_file(const char* fname, const char* buf, size_t sz) {
    int in = find_inode(fname);
    if (in < 0) return -1;
    size_t off = inode_table[in].size;
    if (off + sz > BLOCK_SIZE) return -1;
    memcpy(storage[inode_table[in].blocks[0]] + off, buf, sz);
    inode_table[in].size += sz;
    return sz;
}
</code></pre>
        </section>

        <section>
          <h2>7. File Deletion</h2>
          <pre><code>int delete_file(const char* fname) {
    for (int i = 0; i < MAX_FILES; i++) {
        if (root_directory[i].inode_number &&
            strncmp(root_directory[i].filename, fname, MAX_FILENAME_LEN) == 0) {

            int in = root_directory[i].inode_number - 1;
            // Free blocks
            for (int j = 0; j < MAX_BLOCKS_PER_FILE; j++) {
                int b = inode_table[in].blocks[j];
                if (b >= 0) {
                    block_bitmap[b] = 0;
                    sb.free_blocks++;
                    inode_table[in].blocks[j] = -1;
                }
            }
            // Reset inode and directory
            inode_table[in].inode_number = 0;
            inode_table[in].size = 0;
            root_directory[i].inode_number = 0;
            memset(root_directory[i].filename, 0, MAX_FILENAME_LEN);
            return 0;
        }
    }
    return -1;
}
</code></pre>
        </section>

        <section>
          <h2>8. Directory Listing</h2>
          <pre><code>void list_files() {
    for (int i = 0; i < MAX_FILES; i++) {
        if (root_directory[i].inode_number) {
            print_to_screen(root_directory[i].filename);
            print_to_screen("\n");
        }
    }
}
</code></pre>
        </section>

        <section>
          <h2>9. Multi-User File System</h2>
          <p>
            ApnaOS implements a multi-user filesystem where each user has their own isolated file space with password protection. This ensures data privacy and demonstrates user-space isolation at the filesystem level.
          </p>

          <h3>Enhanced Inode Structure</h3>
          <pre><code>typedef struct {
    uint32_t inode_number;
    uint32_t size;
    int32_t  blocks[MAX_BLOCKS_PER_FILE];
    int32_t  indirect_block;
    int      owner_id;  // New: identifies file owner (0=root, 1-15=users)
    char     is_directory;
    int      parent_inode;
} Inode;</code></pre>

          <h3>User Space Management</h3>
          <pre><code>// Global state
int current_user_space = 0;  // 0=root, 1-15=user IDs
Inode user_space_inodes[MAX_USERS];  // Separate root inode per user

// Create isolated space for a user
void create_user_space(int user_id) {
    if (user_id < 1 || user_id >= MAX_USERS) return;
    
    int inode_num = find_free_inode();
    if (inode_num < 0) return;
    
    user_space_inodes[user_id] = inode_num;
    inode_table[inode_num].inode_number = inode_num + 1;
    inode_table[inode_num].owner_id = user_id;
    inode_table[inode_num].is_directory = 1;
    inode_table[inode_num].parent_inode = -1;
}

// Switch filesystem context to a user
void set_current_user_space(int user_id) {
    if (user_id >= 0 && user_id < MAX_USERS) {
        current_user_space = user_id;
        if (user_id > 0) {
            current_directory_inode = user_space_inodes[user_id];
        } else {
            current_directory_inode = 1;  // Root inode
        }
    }
}</code></pre>

          <h3>Access Control</h3>
          <p>File operations now enforce ownership checks:</p>
          <pre><code>// Modified file operations with owner checks
int read_file(const char* fname, char* buffer, uint32_t size) {
    int in = find_inode_by_name(fname);
    if (in < 0) return -1;
    
    // Permission check: owner, root, or file owned by root
    if (inode_table[in].owner_id != current_user_space && 
        current_user_space != 0 && 
        inode_table[in].owner_id != 0) {
        return -1;  // Access denied
    }
    
    // ... rest of read operation
}

int delete_file(const char* fname) {
    int in = find_inode_by_name(fname);
    if (in < 0) return -1;
    
    // Only owner or root can delete
    if (inode_table[in].owner_id != current_user_space && 
        current_user_space != 0) {
        return -1;  // Access denied
    }
    
    // ... rest of delete operation
}</code></pre>

          <h3>Directory Listing with Filtering</h3>
          <pre><code>void list_files() {
    for (int i = 0; i < MAX_FILES; i++) {
        if (directory[i].inode_number) {
            int in = directory[i].inode_number - 1;
            
            // Show files owned by current user, root, or if user is root
            if (inode_table[in].owner_id == current_user_space ||
                current_user_space == 0 ||
                inode_table[in].owner_id == 0) {
                
                print_to_screen(directory[i].filename);
                print_to_screen("\n");
            }
        }
    }
}</code></pre>

          <h3>Hierarchical Directory Support</h3>
          <p>ApnaOS now supports full path traversal:</p>
          <pre><code>// Path parsing for cd command
void change_directory(const char* path) {
    if (strcmp(path, "..") == 0) {
        // Go to parent directory
        if (current_directory_inode > 0) {
            int parent = inode_table[current_directory_inode].parent_inode;
            if (parent >= 0) {
                current_directory_inode = parent;
            }
        }
    } else if (strcmp(path, "~") == 0) {
        // Go to home directory
        if (current_user_space > 0) {
            current_directory_inode = user_space_inodes[current_user_space];
        } else {
            current_directory_inode = 1;  // Root home
        }
    } else {
        // Navigate by path (e.g., "dir1/dir2/dir3")
        // ... path traversal logic
    }
}</code></pre>
        </section>

        <section>
          <h2>10. User Authentication System</h2>
          <p>
            The filesystem integrates with the user management system to provide secure, isolated spaces:
          </p>
          <pre><code>// User structure (from users/users.h)
typedef struct {
    char username[32];
    uint8_t password_hash[32];
    int home_dir_inode;
    int is_active;
} User;

User users[MAX_USERS];
int current_user_index = 0;  // 0 = root

// Creating a user also creates their file space
int create_user(const char* username, const char* password) {
    // ... hash password, find free slot
    
    create_user_space(user_id);  // Create isolated filesystem
    users[user_id].home_dir_inode = user_space_inodes[user_id];
    
    // ... store user info
}</code></pre>
        </section>

        <section>
          <h2>11. Current Implementation Status</h2>
          <ul>
            <li><strong>Multi-user spaces:</strong> Each user has isolated file storage</li>
            <li><strong>Access control:</strong> Owner checks on all file operations</li>
            <li><strong>Hierarchical directories:</strong> Full path traversal with cd path/to/dir</li>
            <li><strong>Parent directory navigation:</strong> cd .. support</li>
            <li><strong>Home directory:</strong> cd ~ returns to user's home</li>
            <li><strong>Root access:</strong> Root user can access all files</li>
            <li><strong>Password protection:</strong> Secure user authentication</li>
          </ul>
        </section>

        <section>
          <h2>Conclusion</h2>
          <p>
            The ApnaOS filesystem has evolved from a simple in-memory VFS to a sophisticated multi-user system with hierarchical directories, access control, and user isolation. It demonstrates core filesystem concepts including inode management, block allocation, directory services, and user authentication—all while maintaining educational clarity. The modular design allows easy extension to more advanced features as the OS grows.
          </p>
        </section>
      </article>
    </main>

    <footer>
      © 2025 ApnaOS Team
    </footer>
  </div>
</body>
</html>

