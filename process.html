<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ApnaOS – Process Management</title>
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
</head>
<body>
  <div class="sidebar">
    <a href="index.html"><i class="fas fa-house"></i> Home</a>
    <a href="kernel.html"><i class="fas fa-cogs"></i> Kernel</a>
    <a href="process.html" class="active"><i class="fas fa-tasks"></i> Process</a>
    <a href="syscalls.html"><i class="fas fa-code"></i> System Calls</a>
    <a href="cli.html"><i class="fas fa-terminal"></i> CLI</a>
    <a href="interrupts.html"><i class="fas fa-bolt"></i> Interrupts</a>
    <a href="memory.html"><i class="fas fa-microchip"></i> Memory</a>
    <a href="filesystem.html"><i class="fas fa-folder"></i> File System</a>
  </div>

  <div class="container">
    <header class="site-header">
      <h1>Process Management in ApnaOS</h1>
      <p>Understanding process lifecycle, priority scheduling, and context switching in our kernel.</p>
    </header>

    <main>
      <article>

        <!-- Conceptual Foundations -->
        <section>
          <h2>1. Conceptual Foundations</h2>
          <p>
            In any operating system, a <strong>process</strong> represents the execution context of a program, encapsulating its code, data, and CPU state. To manage processes, the kernel maintains a <strong>Process Control Block (PCB)</strong> for each one, storing metadata such as <em>PID</em> (process identifier), <em>state</em>, <em>priority</em>, and pointers to user and kernel stacks. 
          </p>
          <p>
            Processes transition through various states—<code>NEW</code>, <code>READY</code>, <code>RUNNING</code>, and <code>BLOCKED</code>—as they await CPU time, execute, or perform I/O. The kernel uses a <strong>ready queue</strong> to track processes waiting to run. In ApnaOS, we implement a <strong>priority queue</strong> for scheduling: lower numeric priorities run first, with ties handled in a first-come, first-served fashion.
          </p>
          <p>
            <strong>Context switching</strong> is the mechanism that saves the CPU registers of the current process into its PCB, selects a new process, restores its registers, and resumes execution—providing the illusion of concurrency on a single core.
          </p>
        </section>

        <!-- Implementation Details -->
        <section>
          <h2>Implementation Details</h2>

          <h3>1. Process States</h3>
          <p>
            The core data structure is the PCB, defined roughly as:
          </p>
          <pre><code>#define STATE_READY    0
            #define STATE_RUNNING  1
            #define STATE_BLOCKED  2
            #define STATE_NEW      3
            #define STATE_EXIT     4
            #define STATE_ZOMBIE   5            
          </code></pre>
            <ul>
            <li><strong>STATE_NEW (3):</strong> Freshly created process that has not yet been assigned to the scheduler's ready queue.</li>
            <li><strong>STATE_READY (0):</strong> Process that is loaded into memory and is waiting to be scheduled on the CPU.</li>
            <li><strong>STATE_RUNNING (1):</strong> Process is currently executing on the CPU.</li>
            <li><strong>STATE_BLOCKED (2):</strong> Process cannot proceed until some event occurs.</li>
            <li><strong>STATE_EXIT (4):</strong> Process has finished execution.</li>
            <li><strong>STATE_ZOMBIE (5):</strong> Process has exited, but its parent has not yet read its exit status. The PCB remains in the process table until collected by its parent.</li>
            </ul>

          <h3>2. Process Control Block (PCB)</h3>
          <p>
            The core structure of PCB is defined roughly as:
          </p>
          <pre><code>typedef struct PCB {
    uint32_t pid;           
    enum State state;       
    int priority;          
    uint32_t* user_stack_ptr;  
    uint32_t* user_stack_base; 
    uint32_t* kernel_stack_ptr;
    uint32_t* kernel_stack_base;
    bool is_new_child;   
    struct PCB* next;          
    struct PCB* next_in_table; 
} PCB;
</code></pre>
<ul>
  <li>→ <strong>pid</strong>: A unique identifier for each process.</li>
  <li>→ <strong>state</strong>: The current state of the process (e.g., NEW, READY, RUNNING).</li>
  <li>→ <strong>user_stack_ptr</strong>: Points to the current top of the process user-mode stack. On a context switch out of user mode, you save the stack pointer here so you can resume later.</li>
  <li>→ <strong>program_counter</strong>: Holds the saved instruction pointer (EIP for 32-bit x86).</li>
  <li>→ <strong>cr3</strong>: A special CPU control register on x86 architecture used by the CPU to locate the page table (base address of the page directory) of the process.</li>
  <li>→ <strong>priority</strong>: A numeric priority value.</li>
  <li>→ <strong>deadline</strong>: A deadline for the process to complete its task.</li>
  <li>→ <strong>time_to_run</strong>: The remaining time the process has to run.</li>
  <li>→ <strong>PCB* next</strong>: A pointer to the next PCB in the ready queue creating a chain.</li>
  <li>→ <strong>PCB* next_in_table</strong>: Pointer used to link all PCBs in the global process table.</li>
  <li>→ <strong>PCB* parent</strong>: Points to the PCB of the parent process.</li>
  <li>→ <strong>exit_status</strong>: The exit status of the process.</li>
  <li>→ <strong>is_new_child:</strong> A flag that can help the scheduler or process manager know that this PCB was just created by fork().</li>
  <li>→ <strong>user_stack_base:</strong> Base address (lowest address) of the user-mode stack.</li>
  <li>→ <strong>kernel_stack_base:</strong> Base address of the kernel-mode stack to handle system calls and interrupts.</li>
  <li>→ <strong>kernel_stack_ptr:</strong> Points to the current top of the process kernel-mode stack.</li>
</ul>

<pre><code>typedef struct {
  PCB* front;  // First element in the queue
  PCB* rear;   // Last element in the queue
} ProcessQueue;        
</code></pre>

<p>
  front: Points to the first PCB (next to be dequeued).
  rear: Points to the last PCB (where new PCBs are enqueued).
</p>

<h3>3. Initialisation</h3>
<pre><code>uint32_t get_new_pid() { 
  return next_pid++;
}
</code></pre>
  <ul>
    This function returns a new unique process ID.
  </ul>
<pre><code>void initialize_queue(ProcessQueue* queue) {
  queue->front = NULL;
  queue->rear = NULL;
}          
</code></pre>
  <ul>
    Initializes a process queue to be empty by setting both front and rear pointers to NULL.
  </ul>
  <pre><code>bool is_queue_empty(ProcessQueue* queue) {
    return queue->front == NULL;
}
  </code></pre>
    <ul>
      Checks whether the queue has any processes. If the front is NULL, the queue is empty.
    </ul>
    
    <h3>4. Enqueue Process</h3>
          <p>
            Enqueues a process based on priority
          </p>
          <pre><code>void enqueue_process(ProcessQueue* queue, PCB* process) {
            process->next = NULL;
            if (is_queue_empty(queue)) {
                queue->front = process;
                queue->rear = process;
                return;
            }
            if (process->priority < queue->front->priority) {
                process->next = queue->front;
                queue->front = process;
                return;
            }
        
            PCB* current = queue->front;
            while (current->next && current->next->priority <= process->priority) {
                current = current->next;
            }
            process->next = current->next;
            current->next = process;
            if (process->next == NULL) {
                queue->rear = process;
            }
        }        
</code></pre>
<ul>
<li>If the queue is empty, add the process as both front and rear.</li>
<li>If the process has higher priority than the current front, then insert it at the front.</li>
<li>Otherwise, iterate through the queue and insert the process after all processes with higher or equal priority.</li>
<li>If inserted at the end, update rear.</li>
</ul>

<p>
  This implements Shortest Job First scheduling.
</p>
<pre><code>void enqueue_process_sjf(ProcessQueue* queue, PCB* process) {
  process->next = NULL;
  if (is_queue_empty(queue)) {
      queue->front = process;
      queue->rear = process;
      return;
  }
  if (process->time_to_run < queue->front->time_to_run) {
      process->next = queue->front;
      queue->front = process;
      return;
  }

  PCB* current = queue->front;
  while (current->next && current->next->time_to_run <= process->time_to_run) {
      current = current->next;
  }
  process->next = current->next;
  current->next = process;
  if (process->next == NULL) {
      queue->rear = process;
  }
}  
</code></pre>
<ul>
<li>Processes are ordered based on <strong>time_to_run</strong> (how much CPU time they need).</li>
<li>The process with the shortest time is scheduled first.</li>
<li>Insert the process where <strong>time_to_run</strong> increases.</li>
</ul>

<p>
  This uses Earliest Deadline First scheduling.
</p>
<pre><code>void enqueue_process_edf(ProcessQueue* queue, PCB* process) {
  process->next = NULL;
  if (is_queue_empty(queue)) {
      queue->front = process;
      queue->rear = process;
      return;
  }
  if (process->deadline < queue->front->deadline) {
      process->next = queue->front;
      queue->front = process;
      return;
  }

  PCB* current = queue->front;
  while (current->next && current->next->deadline <= process->deadline) {
      current = current->next;
  }
  process->next = current->next;
  current->next = process;
  if (process->next == NULL) {
      queue->rear = process;
  }
}
</code></pre>
<ul>
<li>Processes are sorted based on their <strong>deadline</strong> field.</li>
<li>The one with the earliest (smallest) deadline runs first.</li>
</ul>

<h3>5. Dequeue Process</h3>
<p>removes and returns the process at the front of the queue.</p>
          <pre><code>PCB* dequeue_process(ProcessQueue* queue) {
            if (is_queue_empty(queue)) {
                return NULL;
            }
        
            PCB* process = queue->front;
            queue->front = queue->front->next;
        
            if (queue->front == NULL) {
                queue->rear = NULL;
            }
        
            process->next = NULL;
            debug_print("DEBUG: Dequeued process has pid:");
            debug_int(process->pid);
            return process;
        }        
</code></pre>
<ul>
<li>If queue is empty, return NULL.</li>
<li>Save the node at front.</li>
<li>Advance front to front->next.</li>
<li>If queue becomes empty after removal, set rear to NULL.</li>
<li>Clear the removed node's next pointer.</li>
<li>Return the removed node.</li>
</ul>

        </section>

        <!-- Future Directions -->
        <section>
          <h2>3. Future Directions</h2>
          <ul>
            <li><strong>Time slicing:</strong> Add timer interrupts for preemption and enforce quantum limits.</li>
            <li><strong>Multilevel queues:</strong> Separate interactive vs. batch processes by different priority classes.</li>
            <li><strong>Advanced synchronization:</strong> Integrate semaphores, mutexes, and condition variables.</li>
            <li><strong>Process termination:</strong> Clean up PCB, stacks, and remove from queues.</li>
            <li><strong>Inter-process communication:</strong> Message passing and shared memory mechanisms.</li>
          </ul>
        </section>

        <section>
          <h2>4. Conclusion</h2>
          <p>
            ApnaOS’s process management module lays a clear, extensible foundation for multitasking. By combining a priority-based ready queue,
            robust PCB metadata, and low-level context switching, we ensure fair and efficient CPU utilization across processes.
          </p>
        </section>

      </article>
    </main>

    <footer>
      © 2025 ApnaOS Team
    </footer>
  </div>
</body>
</html>
