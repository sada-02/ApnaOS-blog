<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ApnaOS – Process Management</title>
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
</head>
<body>
  <div class="sidebar">
    <a href="index.html"><i class="fas fa-house"></i> Home</a>
    <a href="kernel.html"><i class="fas fa-cogs"></i> Kernel</a>
    <a href="process.html" class="active"><i class="fas fa-tasks"></i> Process</a>
    <a href="syscalls.html"><i class="fas fa-code"></i> System Calls</a>
    <a href="cli.html"><i class="fas fa-terminal"></i> CLI</a>
    <a href="interrupts.html"><i class="fas fa-bolt"></i> Interrupts</a>
    <a href="memory.html"><i class="fas fa-microchip"></i> Memory</a>
    <a href="filesystem.html"><i class="fas fa-folder"></i> File System</a>
  </div>

  <div class="container">
    <header class="site-header">
      <h1>Process Management in ApnaOS</h1>
      <p>Understanding process lifecycle, priority scheduling, and context switching in our kernel.</p>
    </header>

    <main>
      <article>

        <!-- Conceptual Foundations -->
        <section>
          <h2>1. Conceptual Foundations</h2>
          <p>
            In any operating system, a <strong>process</strong> represents the execution context of a program, encapsulating its code, data, and CPU state. To manage processes, the kernel maintains a <strong>Process Control Block (PCB)</strong> for each one, storing metadata such as <em>PID</em> (process identifier), <em>state</em>, <em>priority</em>, and pointers to user and kernel stacks. 
          </p>
          <p>
            Processes transition through various states—<code>NEW</code>, <code>READY</code>, <code>RUNNING</code>, and <code>BLOCKED</code>—as they await CPU time, execute, or perform I/O. The kernel uses a <strong>ready queue</strong> to track processes waiting to run. In ApnaOS, we implement a <strong>priority queue</strong> for scheduling: lower numeric priorities run first, with ties handled in a first-come, first-served fashion.
          </p>
          <p>
            <strong>Context switching</strong> is the mechanism that saves the CPU registers of the current process into its PCB, selects a new process, restores its registers, and resumes execution—providing the illusion of concurrency on a single core.
          </p>
        </section>

        <!-- Implementation Details -->
        <section>
          <h2>Implementation Details</h2>

          <h3>1. Process States</h3>
          <p>
            The core data structure is the PCB, defined roughly as:
          </p>
          <pre><code>#define STATE_READY    0
            #define STATE_RUNNING  1
            #define STATE_BLOCKED  2
            #define STATE_NEW      3
            #define STATE_EXIT     4
            #define STATE_ZOMBIE   5            
          </code></pre>
            <ul>
            <li><strong>STATE_NEW (3):</strong> Freshly created process that has not yet been assigned to the scheduler's ready queue.</li>
            <li><strong>STATE_READY (0):</strong> Process that is loaded into memory and is waiting to be scheduled on the CPU.</li>
            <li><strong>STATE_RUNNING (1):</strong> Process is currently executing on the CPU.</li>
            <li><strong>STATE_BLOCKED (2):</strong> Process cannot proceed until some event occurs.</li>
            <li><strong>STATE_EXIT (4):</strong> Process has finished execution.</li>
            <li><strong>STATE_ZOMBIE (5):</strong> Process has exited, but its parent has not yet read its exit status. The PCB remains in the process table until collected by its parent.</li>
            </ul>

          <h3>2. Process Control Block (PCB)</h3>
          <p>
            The core structure of PCB is defined roughly as:
          </p>
          <pre><code>typedef struct PCB {
    uint32_t pid;           
    enum State state;       
    int priority;          
    uint32_t* user_stack_ptr;  
    uint32_t* user_stack_base; 
    uint32_t* kernel_stack_ptr;
    uint32_t* kernel_stack_base;
    bool is_new_child;   
    struct PCB* next;          
    struct PCB* next_in_table; 
} PCB;
</code></pre>
<ul>
  <li>→ <strong>pid:</strong> A unique identifier for each process.</li>
  <li>→ <strong>state:</strong> The current state of the process (e.g., NEW, READY, RUNNING).</li>
  <li>→ <strong>user_stack_ptr:</strong> Points to the current top of the process user-mode stack. On a context switch out of user mode, you save the stack pointer here so you can resume later.</li>
  <li>→ <strong>program_counter:</strong> Holds the saved instruction pointer (EIP for 32-bit x86).</li>
  <li>→ <strong>cr3:</strong> A special CPU control register on x86 architecture used by the CPU to locate the page table (base address of the page directory) of the process.</li>
  <li>→ <strong>priority:</strong> A numeric priority value.</li>
  <li>→ <strong>deadline:</strong> A deadline for the process to complete its task.</li>
  <li>→ <strong>time_to_run:</strong> The remaining time the process has to run.</li>
  <li>→ <strong>PCB* next:</strong> A pointer to the next PCB in the ready queue creating a chain.</li>
  <li>→ <strong>PCB* next_in_table:</strong> Pointer used to link all PCBs in the global process table.</li>
  <li>→ <strong>PCB* parent:</strong> Points to the PCB of the parent process.</li>
  <li>→ <strong>exit_status:</strong> The exit status of the process.</li>
  <li>→ <strong>is_new_child:</strong> A flag that can help the scheduler or process manager know that this PCB was just created by fork().</li>
  <li>→ <strong>user_stack_base:</strong> Base address (lowest address) of the user-mode stack.</li>
  <li>→ <strong>kernel_stack_base:</strong> Base address of the kernel-mode stack to handle system calls and interrupts.</li>
  <li>→ <strong>kernel_stack_ptr:</strong> Points to the current top of the process kernel-mode stack.</li>
</ul>

<pre><code>typedef struct {
  PCB* front;  // First element in the queue
  PCB* rear;   // Last element in the queue
} ProcessQueue;        
</code></pre>

<p>
  front: Points to the first PCB (next to be dequeued).
  rear: Points to the last PCB (where new PCBs are enqueued).
</p>
          <h3>2.2 PID Generation & Process Table</h3>
          <p>
            Each process gets a unique PID by incrementing <code>next_pid</code>:
          </p>
          <pre><code>static uint32_t next_pid = 1;
uint32_t get_new_pid() {
    return next_pid++;
}
</code></pre>
          <p>
            New PCBs are linked into a global <em>process table</em> so the kernel can track all processes for cleanup and resource management.
          </p>

          <h3>2.3 Ready Queue & Priority-based Enqueue</h3>
          <p>
            We maintain a <code>ProcessQueue</code> with <code>front</code> and <code>rear</code> pointers. To insert a process, <code>enqueue_process()</code> finds the proper position by priority:
          </p>
          <ol>
            <li>If the queue is empty, both <code>front</code> and <code>rear</code> point to the new PCB.</li>
            <li>If the new process has a higher priority (numeric <em>lower</em>) than the current front, insert at the beginning.</li>
            <li>Otherwise, walk the list until finding a process with greater priority value, and insert before it. Equal priorities are enqueued in arrival order.</li>
          </ol>
          <pre><code>void enqueue_process(ProcessQueue* q, PCB* p) {
    p->next = NULL;
    if (is_queue_empty(q)) { /* empty */ }
    else if (p->priority < q->front->priority) { /* front insertion */ }
    else {
        PCB* cur = q->front;
        while (cur->next && cur->next->priority <= p->priority) {
            cur = cur->next;
        }
        // insert after cur
    }
    // update q->rear if needed
}
</code></pre>

          <h3>2.4 Context Switching & Scheduler</h3>
          <p>
            The <code>schedule()</code> function embodies preemptive scheduling:
          </p>
          <ol>
            <li>If <code>current_process</code> is running, mark it <code>READY</code> and re-enqueue it.</li>
            <li>Dequeue the highest-priority ready process.</li>
            <li>If none exists, enter the kernel’s CLI loop.</li>
            <li>Otherwise, set its state to <code>RUNNING</code> and invoke an assembly stub to switch stacks:
              <ul>
                <li>Save the old kernel <code>ESP</code> into its PCB.</li>
                <li>Load the new process’s kernel and user <code>ESP</code> and <code>EBP</code>.</li>
                <li>Execute <code>ret</code> to resume user-mode <code>EIP</code>.</li>
              </ul>
            </li>
          </ol>
          <pre><code>void schedule() {
    if (current_process) {
        current_process->state = STATE_READY;
        enqueue_process(&ready_queue, current_process);
    }
    PCB* next = dequeue_process(&ready_queue);
    if (!next) { cli_loop(); }
    next->state = STATE_RUNNING;
    // assembly magic to swap ESP/EBP and ret
}
</code></pre>

          <h3>2.5 Process Creation (<code>create_process</code>)</h3>
          <p>
            To create a new process with a given <code>entry_point</code>, <code>stack_top</code>, and <code>priority</code>:
          </p>
          <ol>
            <li>Allocate and initialize the PCB.</li>
            <li>Assign PID, state <code>NEW</code>, and priority.</li>
            <li>Set up the user-mode stack: reserve space, push the entry point (return address), and a dummy EBP.</li>
            <li>Allocate a kernel stack via <code>kmalloc</code> and record its <code>ESP</code>.</li>
            <li>Link into the global process table.</li>
            <li>Mark state <code>READY</code> and enqueue.</li>
          </ol>
          <pre><code>PCB* create_process(uint32_t pid, uint32_t* entry, uint32_t* stack_top, int prio) {
    PCB* p = kmalloc(sizeof(PCB));
    p->pid = pid;
    p->state = STATE_NEW;
    p->priority = prio;
    // prepare user stack
    *(--stack_top) = (uint32_t)entry;
    *(--stack_top) = 0;
    p->user_stack_ptr = stack_top;
    allocate_kernel_stack(p);
    // add to process table & ready queue
    return p;
}
</code></pre>

        </section>

        <!-- Future Directions -->
        <section>
          <h2>3. Future Directions</h2>
          <ul>
            <li><strong>Time slicing:</strong> Add timer interrupts for preemption and enforce quantum limits.</li>
            <li><strong>Multilevel queues:</strong> Separate interactive vs. batch processes by different priority classes.</li>
            <li><strong>Advanced synchronization:</strong> Integrate semaphores, mutexes, and condition variables.</li>
            <li><strong>Process termination:</strong> Clean up PCB, stacks, and remove from queues.</li>
            <li><strong>Inter-process communication:</strong> Message passing and shared memory mechanisms.</li>
          </ul>
        </section>

        <section>
          <h2>4. Conclusion</h2>
          <p>
            ApnaOS’s process management module lays a clear, extensible foundation for multitasking. By combining a priority-based ready queue,
            robust PCB metadata, and low-level context switching, we ensure fair and efficient CPU utilization across processes.
          </p>
        </section>

      </article>
    </main>

    <footer>
      © 2025 ApnaOS Team
    </footer>
  </div>
</body>
</html>
